// automatically generated by the FlatBuffers compiler, do not modify
extern crate flatbuffers;
use std::mem;
use std::cmp::Ordering;
use self::flatbuffers::{EndianScalar, Follow};
use super::*;
pub enum FieldOffset {}
#[derive(Copy, Clone, PartialEq)]

/// ----------------------------------------------------------------------
/// A field represents a named column in a record / row batch or child of a
/// nested type.
pub struct Field<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Field<'a> {
  type Inner = Field<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> Field<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_NULLABLE: flatbuffers::VOffsetT = 6;
  pub const VT_TYPE_TYPE: flatbuffers::VOffsetT = 8;
  pub const VT_TYPE_: flatbuffers::VOffsetT = 10;
  pub const VT_DICTIONARY: flatbuffers::VOffsetT = 12;
  pub const VT_CHILDREN: flatbuffers::VOffsetT = 14;
  pub const VT_CUSTOM_METADATA: flatbuffers::VOffsetT = 16;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Field { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args FieldArgs<'args>
  ) -> flatbuffers::WIPOffset<Field<'bldr>> {
    let mut builder = FieldBuilder::new(_fbb);
    if let Some(x) = args.custom_metadata { builder.add_custom_metadata(x); }
    if let Some(x) = args.children { builder.add_children(x); }
    if let Some(x) = args.dictionary { builder.add_dictionary(x); }
    if let Some(x) = args.type_ { builder.add_type_(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.add_type_type(args.type_type);
    builder.add_nullable(args.nullable);
    builder.finish()
  }


  /// Name is not required, in i.e. a List
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Field::VT_NAME, None)
  }
  /// Whether or not this field can contain nulls. Should be true in general.
  #[inline]
  pub fn nullable(&self) -> bool {
    self._tab.get::<bool>(Field::VT_NULLABLE, Some(false)).unwrap()
  }
  #[inline]
  pub fn type_type(&self) -> Type {
    self._tab.get::<Type>(Field::VT_TYPE_TYPE, Some(Type::NONE)).unwrap()
  }
  /// This is the type of the decoded value if the field is dictionary encoded.
  #[inline]
  pub fn type_(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Field::VT_TYPE_, None)
  }
  /// Present only if the field is dictionary encoded.
  #[inline]
  pub fn dictionary(&self) -> Option<DictionaryEncoding<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<DictionaryEncoding>>(Field::VT_DICTIONARY, None)
  }
  /// children apply only to nested data types like Struct, List and Union. For
  /// primitive types children will have length 0.
  #[inline]
  pub fn children(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Field<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Field>>>>(Field::VT_CHILDREN, None)
  }
  /// User-defined metadata
  #[inline]
  pub fn custom_metadata(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue>>>>(Field::VT_CUSTOM_METADATA, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn type__as_null(&self) -> Option<Null<'a>> {
    if self.type_type() == Type::Null {
      self.type_().map(Null::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn type__as_int(&self) -> Option<Int<'a>> {
    if self.type_type() == Type::Int {
      self.type_().map(Int::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn type__as_floating_point(&self) -> Option<FloatingPoint<'a>> {
    if self.type_type() == Type::FloatingPoint {
      self.type_().map(FloatingPoint::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn type__as_binary(&self) -> Option<Binary<'a>> {
    if self.type_type() == Type::Binary {
      self.type_().map(Binary::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn type__as_utf_8(&self) -> Option<Utf8<'a>> {
    if self.type_type() == Type::Utf8 {
      self.type_().map(Utf8::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn type__as_bool(&self) -> Option<Bool<'a>> {
    if self.type_type() == Type::Bool {
      self.type_().map(Bool::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn type__as_decimal(&self) -> Option<Decimal<'a>> {
    if self.type_type() == Type::Decimal {
      self.type_().map(Decimal::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn type__as_date(&self) -> Option<Date<'a>> {
    if self.type_type() == Type::Date {
      self.type_().map(Date::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn type__as_time(&self) -> Option<Time<'a>> {
    if self.type_type() == Type::Time {
      self.type_().map(Time::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn type__as_timestamp(&self) -> Option<Timestamp<'a>> {
    if self.type_type() == Type::Timestamp {
      self.type_().map(Timestamp::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn type__as_interval(&self) -> Option<Interval<'a>> {
    if self.type_type() == Type::Interval {
      self.type_().map(Interval::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn type__as_list(&self) -> Option<List<'a>> {
    if self.type_type() == Type::List {
      self.type_().map(List::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn type__as_struct_(&self) -> Option<Struct_<'a>> {
    if self.type_type() == Type::Struct_ {
      self.type_().map(Struct_::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn type__as_union(&self) -> Option<Union<'a>> {
    if self.type_type() == Type::Union {
      self.type_().map(Union::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn type__as_fixed_size_binary(&self) -> Option<FixedSizeBinary<'a>> {
    if self.type_type() == Type::FixedSizeBinary {
      self.type_().map(FixedSizeBinary::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn type__as_fixed_size_list(&self) -> Option<FixedSizeList<'a>> {
    if self.type_type() == Type::FixedSizeList {
      self.type_().map(FixedSizeList::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn type__as_map(&self) -> Option<Map<'a>> {
    if self.type_type() == Type::Map {
      self.type_().map(Map::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn type__as_duration(&self) -> Option<Duration<'a>> {
    if self.type_type() == Type::Duration {
      self.type_().map(Duration::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn type__as_large_binary(&self) -> Option<LargeBinary<'a>> {
    if self.type_type() == Type::LargeBinary {
      self.type_().map(LargeBinary::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn type__as_large_utf_8(&self) -> Option<LargeUtf8<'a>> {
    if self.type_type() == Type::LargeUtf8 {
      self.type_().map(LargeUtf8::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn type__as_large_list(&self) -> Option<LargeList<'a>> {
    if self.type_type() == Type::LargeList {
      self.type_().map(LargeList::init_from_table)
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for Field<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<bool>("nullable", Self::VT_NULLABLE, false)?
     .visit_union::<Type, _>("type__type", Self::VT_TYPE_TYPE, "type_", Self::VT_TYPE_, false, |key, v, pos| {
        match key {
          Type::Null => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Null>>("Type::Null", pos),
          Type::Int => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Int>>("Type::Int", pos),
          Type::FloatingPoint => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FloatingPoint>>("Type::FloatingPoint", pos),
          Type::Binary => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Binary>>("Type::Binary", pos),
          Type::Utf8 => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Utf8>>("Type::Utf8", pos),
          Type::Bool => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Bool>>("Type::Bool", pos),
          Type::Decimal => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Decimal>>("Type::Decimal", pos),
          Type::Date => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Date>>("Type::Date", pos),
          Type::Time => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Time>>("Type::Time", pos),
          Type::Timestamp => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Timestamp>>("Type::Timestamp", pos),
          Type::Interval => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Interval>>("Type::Interval", pos),
          Type::List => v.verify_union_variant::<flatbuffers::ForwardsUOffset<List>>("Type::List", pos),
          Type::Struct_ => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Struct_>>("Type::Struct_", pos),
          Type::Union => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Union>>("Type::Union", pos),
          Type::FixedSizeBinary => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FixedSizeBinary>>("Type::FixedSizeBinary", pos),
          Type::FixedSizeList => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FixedSizeList>>("Type::FixedSizeList", pos),
          Type::Map => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Map>>("Type::Map", pos),
          Type::Duration => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Duration>>("Type::Duration", pos),
          Type::LargeBinary => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LargeBinary>>("Type::LargeBinary", pos),
          Type::LargeUtf8 => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LargeUtf8>>("Type::LargeUtf8", pos),
          Type::LargeList => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LargeList>>("Type::LargeList", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<flatbuffers::ForwardsUOffset<DictionaryEncoding>>("dictionary", Self::VT_DICTIONARY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Field>>>>("children", Self::VT_CHILDREN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<KeyValue>>>>("custom_metadata", Self::VT_CUSTOM_METADATA, false)?
     .finish();
    Ok(())
  }
}
pub struct FieldArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub nullable: bool,
    pub type_type: Type,
    pub type_: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub dictionary: Option<flatbuffers::WIPOffset<DictionaryEncoding<'a>>>,
    pub children: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Field<'a>>>>>,
    pub custom_metadata: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue<'a>>>>>,
}
impl<'a> Default for FieldArgs<'a> {
  #[inline]
  fn default() -> Self {
    FieldArgs {
      name: None,
      nullable: false,
      type_type: Type::NONE,
      type_: None,
      dictionary: None,
      children: None,
      custom_metadata: None,
    }
  }
}
pub struct FieldBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FieldBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Field::VT_NAME, name);
  }
  #[inline]
  pub fn add_nullable(&mut self, nullable: bool) {
    self.fbb_.push_slot::<bool>(Field::VT_NULLABLE, nullable, false);
  }
  #[inline]
  pub fn add_type_type(&mut self, type_type: Type) {
    self.fbb_.push_slot::<Type>(Field::VT_TYPE_TYPE, type_type, Type::NONE);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Field::VT_TYPE_, type_);
  }
  #[inline]
  pub fn add_dictionary(&mut self, dictionary: flatbuffers::WIPOffset<DictionaryEncoding<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DictionaryEncoding>>(Field::VT_DICTIONARY, dictionary);
  }
  #[inline]
  pub fn add_children(&mut self, children: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Field<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Field::VT_CHILDREN, children);
  }
  #[inline]
  pub fn add_custom_metadata(&mut self, custom_metadata: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<KeyValue<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Field::VT_CUSTOM_METADATA, custom_metadata);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FieldBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FieldBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Field<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Field<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Field");
      ds.field("name", &self.name());
      ds.field("nullable", &self.nullable());
      ds.field("type_type", &self.type_type());
      match self.type_type() {
        Type::Null => {
          if let Some(x) = self.type__as_null() {
            ds.field("type_", &x)
          } else {
            ds.field("type_", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Type::Int => {
          if let Some(x) = self.type__as_int() {
            ds.field("type_", &x)
          } else {
            ds.field("type_", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Type::FloatingPoint => {
          if let Some(x) = self.type__as_floating_point() {
            ds.field("type_", &x)
          } else {
            ds.field("type_", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Type::Binary => {
          if let Some(x) = self.type__as_binary() {
            ds.field("type_", &x)
          } else {
            ds.field("type_", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Type::Utf8 => {
          if let Some(x) = self.type__as_utf_8() {
            ds.field("type_", &x)
          } else {
            ds.field("type_", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Type::Bool => {
          if let Some(x) = self.type__as_bool() {
            ds.field("type_", &x)
          } else {
            ds.field("type_", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Type::Decimal => {
          if let Some(x) = self.type__as_decimal() {
            ds.field("type_", &x)
          } else {
            ds.field("type_", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Type::Date => {
          if let Some(x) = self.type__as_date() {
            ds.field("type_", &x)
          } else {
            ds.field("type_", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Type::Time => {
          if let Some(x) = self.type__as_time() {
            ds.field("type_", &x)
          } else {
            ds.field("type_", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Type::Timestamp => {
          if let Some(x) = self.type__as_timestamp() {
            ds.field("type_", &x)
          } else {
            ds.field("type_", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Type::Interval => {
          if let Some(x) = self.type__as_interval() {
            ds.field("type_", &x)
          } else {
            ds.field("type_", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Type::List => {
          if let Some(x) = self.type__as_list() {
            ds.field("type_", &x)
          } else {
            ds.field("type_", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Type::Struct_ => {
          if let Some(x) = self.type__as_struct_() {
            ds.field("type_", &x)
          } else {
            ds.field("type_", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Type::Union => {
          if let Some(x) = self.type__as_union() {
            ds.field("type_", &x)
          } else {
            ds.field("type_", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Type::FixedSizeBinary => {
          if let Some(x) = self.type__as_fixed_size_binary() {
            ds.field("type_", &x)
          } else {
            ds.field("type_", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Type::FixedSizeList => {
          if let Some(x) = self.type__as_fixed_size_list() {
            ds.field("type_", &x)
          } else {
            ds.field("type_", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Type::Map => {
          if let Some(x) = self.type__as_map() {
            ds.field("type_", &x)
          } else {
            ds.field("type_", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Type::Duration => {
          if let Some(x) = self.type__as_duration() {
            ds.field("type_", &x)
          } else {
            ds.field("type_", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Type::LargeBinary => {
          if let Some(x) = self.type__as_large_binary() {
            ds.field("type_", &x)
          } else {
            ds.field("type_", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Type::LargeUtf8 => {
          if let Some(x) = self.type__as_large_utf_8() {
            ds.field("type_", &x)
          } else {
            ds.field("type_", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Type::LargeList => {
          if let Some(x) = self.type__as_large_list() {
            ds.field("type_", &x)
          } else {
            ds.field("type_", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("type_", &x)
        },
      };
      ds.field("dictionary", &self.dictionary());
      ds.field("children", &self.children());
      ds.field("custom_metadata", &self.custom_metadata());
      ds.finish()
  }
}
