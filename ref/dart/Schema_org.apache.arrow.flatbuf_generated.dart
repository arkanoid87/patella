// automatically generated by the FlatBuffers compiler, do not modify
// ignore_for_file: unused_import, unused_field, unused_element, unused_local_variable

library org.apache.arrow.flatbuf;

import 'dart:typed_data' show Uint8List;
import 'package:flat_buffers/flat_buffers.dart' as fb;


class MetadataVersion {
  final int value;
  const MetadataVersion._(this.value);

  factory MetadataVersion.fromValue(int value) {
    final result = values[value];
    if (result == null) {
      throw StateError('Invalid value $value for bit flag enum MetadataVersion');
    }
    return result;
  }

  static MetadataVersion? _createOrNull(int? value) => 
      value == null ? null : MetadataVersion.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 4;
  static bool containsValue(int value) => values.containsKey(value);

  ///  0.1.0 (October 2016).
  static const MetadataVersion V1 = MetadataVersion._(0);

  ///  0.2.0 (February 2017). Non-backwards compatible with V1.
  static const MetadataVersion V2 = MetadataVersion._(1);

  ///  0.3.0 -> 0.7.1 (May - December 2017). Non-backwards compatible with V2.
  static const MetadataVersion V3 = MetadataVersion._(2);

  ///  >= 0.8.0 (December 2017). Non-backwards compatible with V3.
  static const MetadataVersion V4 = MetadataVersion._(3);

  ///  >= 1.0.0 (July 2020. Backwards compatible with V4 (V5 readers can read V4
  ///  metadata and IPC messages). Implementations are recommended to provide a
  ///  V4 compatibility mode with V5 format changes disabled.
  /// 
  ///  Incompatible changes between V4 and V5:
  ///  - Union buffer layout has changed. In V5, Unions don't have a validity
  ///    bitmap buffer.
  static const MetadataVersion V5 = MetadataVersion._(4);
  static const Map<int, MetadataVersion> values = {
    0: V1,
    1: V2,
    2: V3,
    3: V4,
    4: V5};

  static const fb.Reader<MetadataVersion> reader = _MetadataVersionReader();

  @override
  String toString() {
    return 'MetadataVersion{value: $value}';
  }
}

class _MetadataVersionReader extends fb.Reader<MetadataVersion> {
  const _MetadataVersionReader();

  @override
  int get size => 1;

  @override
  MetadataVersion read(fb.BufferContext bc, int offset) =>
      MetadataVersion.fromValue(const fb.Int16Reader().read(bc, offset));
}

///  Represents Arrow Features that might not have full support
///  within implementations. This is intended to be used in
///  two scenarios:
///   1.  A mechanism for readers of Arrow Streams
///       and files to understand that the stream or file makes
///       use of a feature that isn't supported or unknown to
///       the implementation (and therefore can meet the Arrow
///       forward compatibility guarantees).
///   2.  A means of negotiating between a client and server
///       what features a stream is allowed to use. The enums
///       values here are intented to represent higher level
///       features, additional details maybe negotiated
///       with key-value pairs specific to the protocol.
/// 
///  Enums added to this list should be assigned power-of-two values
///  to facilitate exchanging and comparing bitmaps for supported
///  features.
class Feature {
  final int value;
  const Feature._(this.value);

  factory Feature.fromValue(int value) {
    final result = values[value];
    if (result == null) {
      throw StateError('Invalid value $value for bit flag enum Feature');
    }
    return result;
  }

  static Feature? _createOrNull(int? value) => 
      value == null ? null : Feature.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 2;
  static bool containsValue(int value) => values.containsKey(value);

  ///  Needed to make flatbuffers happy.
  static const Feature UNUSED = Feature._(0);

  ///  The stream makes use of multiple full dictionaries with the
  ///  same ID and assumes clients implement dictionary replacement
  ///  correctly.
  static const Feature DICTIONARY_REPLACEMENT = Feature._(1);

  ///  The stream makes use of compressed bodies as described
  ///  in Message.fbs.
  static const Feature COMPRESSED_BODY = Feature._(2);
  static const Map<int, Feature> values = {
    0: UNUSED,
    1: DICTIONARY_REPLACEMENT,
    2: COMPRESSED_BODY};

  static const fb.Reader<Feature> reader = _FeatureReader();

  @override
  String toString() {
    return 'Feature{value: $value}';
  }
}

class _FeatureReader extends fb.Reader<Feature> {
  const _FeatureReader();

  @override
  int get size => 1;

  @override
  Feature read(fb.BufferContext bc, int offset) =>
      Feature.fromValue(const fb.Int64Reader().read(bc, offset));
}

class UnionMode {
  final int value;
  const UnionMode._(this.value);

  factory UnionMode.fromValue(int value) {
    final result = values[value];
    if (result == null) {
      throw StateError('Invalid value $value for bit flag enum UnionMode');
    }
    return result;
  }

  static UnionMode? _createOrNull(int? value) => 
      value == null ? null : UnionMode.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 1;
  static bool containsValue(int value) => values.containsKey(value);

  static const UnionMode Sparse = UnionMode._(0);
  static const UnionMode Dense = UnionMode._(1);
  static const Map<int, UnionMode> values = {
    0: Sparse,
    1: Dense};

  static const fb.Reader<UnionMode> reader = _UnionModeReader();

  @override
  String toString() {
    return 'UnionMode{value: $value}';
  }
}

class _UnionModeReader extends fb.Reader<UnionMode> {
  const _UnionModeReader();

  @override
  int get size => 1;

  @override
  UnionMode read(fb.BufferContext bc, int offset) =>
      UnionMode.fromValue(const fb.Int16Reader().read(bc, offset));
}

class Precision {
  final int value;
  const Precision._(this.value);

  factory Precision.fromValue(int value) {
    final result = values[value];
    if (result == null) {
      throw StateError('Invalid value $value for bit flag enum Precision');
    }
    return result;
  }

  static Precision? _createOrNull(int? value) => 
      value == null ? null : Precision.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 2;
  static bool containsValue(int value) => values.containsKey(value);

  static const Precision HALF = Precision._(0);
  static const Precision SINGLE = Precision._(1);
  static const Precision DOUBLE = Precision._(2);
  static const Map<int, Precision> values = {
    0: HALF,
    1: SINGLE,
    2: DOUBLE};

  static const fb.Reader<Precision> reader = _PrecisionReader();

  @override
  String toString() {
    return 'Precision{value: $value}';
  }
}

class _PrecisionReader extends fb.Reader<Precision> {
  const _PrecisionReader();

  @override
  int get size => 1;

  @override
  Precision read(fb.BufferContext bc, int offset) =>
      Precision.fromValue(const fb.Int16Reader().read(bc, offset));
}

class DateUnit {
  final int value;
  const DateUnit._(this.value);

  factory DateUnit.fromValue(int value) {
    final result = values[value];
    if (result == null) {
      throw StateError('Invalid value $value for bit flag enum DateUnit');
    }
    return result;
  }

  static DateUnit? _createOrNull(int? value) => 
      value == null ? null : DateUnit.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 1;
  static bool containsValue(int value) => values.containsKey(value);

  static const DateUnit DAY = DateUnit._(0);
  static const DateUnit MILLISECOND = DateUnit._(1);
  static const Map<int, DateUnit> values = {
    0: DAY,
    1: MILLISECOND};

  static const fb.Reader<DateUnit> reader = _DateUnitReader();

  @override
  String toString() {
    return 'DateUnit{value: $value}';
  }
}

class _DateUnitReader extends fb.Reader<DateUnit> {
  const _DateUnitReader();

  @override
  int get size => 1;

  @override
  DateUnit read(fb.BufferContext bc, int offset) =>
      DateUnit.fromValue(const fb.Int16Reader().read(bc, offset));
}

class TimeUnit {
  final int value;
  const TimeUnit._(this.value);

  factory TimeUnit.fromValue(int value) {
    final result = values[value];
    if (result == null) {
      throw StateError('Invalid value $value for bit flag enum TimeUnit');
    }
    return result;
  }

  static TimeUnit? _createOrNull(int? value) => 
      value == null ? null : TimeUnit.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 3;
  static bool containsValue(int value) => values.containsKey(value);

  static const TimeUnit SECOND = TimeUnit._(0);
  static const TimeUnit MILLISECOND = TimeUnit._(1);
  static const TimeUnit MICROSECOND = TimeUnit._(2);
  static const TimeUnit NANOSECOND = TimeUnit._(3);
  static const Map<int, TimeUnit> values = {
    0: SECOND,
    1: MILLISECOND,
    2: MICROSECOND,
    3: NANOSECOND};

  static const fb.Reader<TimeUnit> reader = _TimeUnitReader();

  @override
  String toString() {
    return 'TimeUnit{value: $value}';
  }
}

class _TimeUnitReader extends fb.Reader<TimeUnit> {
  const _TimeUnitReader();

  @override
  int get size => 1;

  @override
  TimeUnit read(fb.BufferContext bc, int offset) =>
      TimeUnit.fromValue(const fb.Int16Reader().read(bc, offset));
}

class IntervalUnit {
  final int value;
  const IntervalUnit._(this.value);

  factory IntervalUnit.fromValue(int value) {
    final result = values[value];
    if (result == null) {
      throw StateError('Invalid value $value for bit flag enum IntervalUnit');
    }
    return result;
  }

  static IntervalUnit? _createOrNull(int? value) => 
      value == null ? null : IntervalUnit.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 2;
  static bool containsValue(int value) => values.containsKey(value);

  static const IntervalUnit YEAR_MONTH = IntervalUnit._(0);
  static const IntervalUnit DAY_TIME = IntervalUnit._(1);
  static const IntervalUnit MONTH_DAY_NANO = IntervalUnit._(2);
  static const Map<int, IntervalUnit> values = {
    0: YEAR_MONTH,
    1: DAY_TIME,
    2: MONTH_DAY_NANO};

  static const fb.Reader<IntervalUnit> reader = _IntervalUnitReader();

  @override
  String toString() {
    return 'IntervalUnit{value: $value}';
  }
}

class _IntervalUnitReader extends fb.Reader<IntervalUnit> {
  const _IntervalUnitReader();

  @override
  int get size => 1;

  @override
  IntervalUnit read(fb.BufferContext bc, int offset) =>
      IntervalUnit.fromValue(const fb.Int16Reader().read(bc, offset));
}

///  ----------------------------------------------------------------------
///  Top-level Type value, enabling extensible type-specific metadata. We can
///  add new logical types to Type without breaking backwards compatibility
class TypeTypeId {
  final int value;
  const TypeTypeId._(this.value);

  factory TypeTypeId.fromValue(int value) {
    final result = values[value];
    if (result == null) {
      throw StateError('Invalid value $value for bit flag enum TypeTypeId');
    }
    return result;
  }

  static TypeTypeId? _createOrNull(int? value) => 
      value == null ? null : TypeTypeId.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 21;
  static bool containsValue(int value) => values.containsKey(value);

  static const TypeTypeId NONE = TypeTypeId._(0);
  static const TypeTypeId Null = TypeTypeId._(1);
  static const TypeTypeId Int = TypeTypeId._(2);
  static const TypeTypeId FloatingPoint = TypeTypeId._(3);
  static const TypeTypeId Binary = TypeTypeId._(4);
  static const TypeTypeId Utf8 = TypeTypeId._(5);
  static const TypeTypeId Bool = TypeTypeId._(6);
  static const TypeTypeId Decimal = TypeTypeId._(7);
  static const TypeTypeId Date = TypeTypeId._(8);
  static const TypeTypeId Time = TypeTypeId._(9);
  static const TypeTypeId Timestamp = TypeTypeId._(10);
  static const TypeTypeId Interval = TypeTypeId._(11);
  static const TypeTypeId List = TypeTypeId._(12);
  static const TypeTypeId Struct_ = TypeTypeId._(13);
  static const TypeTypeId Union = TypeTypeId._(14);
  static const TypeTypeId FixedSizeBinary = TypeTypeId._(15);
  static const TypeTypeId FixedSizeList = TypeTypeId._(16);
  static const TypeTypeId Map = TypeTypeId._(17);
  static const TypeTypeId Duration = TypeTypeId._(18);
  static const TypeTypeId LargeBinary = TypeTypeId._(19);
  static const TypeTypeId LargeUtf8 = TypeTypeId._(20);
  static const TypeTypeId LargeList = TypeTypeId._(21);
  static const Map<int, TypeTypeId> values = {
    0: NONE,
    1: Null,
    2: Int,
    3: FloatingPoint,
    4: Binary,
    5: Utf8,
    6: Bool,
    7: Decimal,
    8: Date,
    9: Time,
    10: Timestamp,
    11: Interval,
    12: List,
    13: Struct_,
    14: Union,
    15: FixedSizeBinary,
    16: FixedSizeList,
    17: Map,
    18: Duration,
    19: LargeBinary,
    20: LargeUtf8,
    21: LargeList};

  static const fb.Reader<TypeTypeId> reader = _TypeTypeIdReader();

  @override
  String toString() {
    return 'TypeTypeId{value: $value}';
  }
}

class _TypeTypeIdReader extends fb.Reader<TypeTypeId> {
  const _TypeTypeIdReader();

  @override
  int get size => 1;

  @override
  TypeTypeId read(fb.BufferContext bc, int offset) =>
      TypeTypeId.fromValue(const fb.Uint8Reader().read(bc, offset));
}

///  ----------------------------------------------------------------------
///  Dictionary encoding metadata
///  Maintained for forwards compatibility, in the future
///  Dictionaries might be explicit maps between integers and values
///  allowing for non-contiguous index values
class DictionaryKind {
  final int value;
  const DictionaryKind._(this.value);

  factory DictionaryKind.fromValue(int value) {
    final result = values[value];
    if (result == null) {
      throw StateError('Invalid value $value for bit flag enum DictionaryKind');
    }
    return result;
  }

  static DictionaryKind? _createOrNull(int? value) => 
      value == null ? null : DictionaryKind.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 0;
  static bool containsValue(int value) => values.containsKey(value);

  static const DictionaryKind DenseArray = DictionaryKind._(0);
  static const Map<int, DictionaryKind> values = {
    0: DenseArray};

  static const fb.Reader<DictionaryKind> reader = _DictionaryKindReader();

  @override
  String toString() {
    return 'DictionaryKind{value: $value}';
  }
}

class _DictionaryKindReader extends fb.Reader<DictionaryKind> {
  const _DictionaryKindReader();

  @override
  int get size => 1;

  @override
  DictionaryKind read(fb.BufferContext bc, int offset) =>
      DictionaryKind.fromValue(const fb.Int16Reader().read(bc, offset));
}

///  ----------------------------------------------------------------------
///  Endianness of the platform producing the data
class Endianness {
  final int value;
  const Endianness._(this.value);

  factory Endianness.fromValue(int value) {
    final result = values[value];
    if (result == null) {
      throw StateError('Invalid value $value for bit flag enum Endianness');
    }
    return result;
  }

  static Endianness? _createOrNull(int? value) => 
      value == null ? null : Endianness.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 1;
  static bool containsValue(int value) => values.containsKey(value);

  static const Endianness Little = Endianness._(0);
  static const Endianness Big = Endianness._(1);
  static const Map<int, Endianness> values = {
    0: Little,
    1: Big};

  static const fb.Reader<Endianness> reader = _EndiannessReader();

  @override
  String toString() {
    return 'Endianness{value: $value}';
  }
}

class _EndiannessReader extends fb.Reader<Endianness> {
  const _EndiannessReader();

  @override
  int get size => 1;

  @override
  Endianness read(fb.BufferContext bc, int offset) =>
      Endianness.fromValue(const fb.Int16Reader().read(bc, offset));
}

///  These are stored in the flatbuffer in the Type union below
class Null {
  Null._(this._bc, this._bcOffset);
  factory Null(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<Null> reader = _NullReader();

  final fb.BufferContext _bc;
  final int _bcOffset;


  @override
  String toString() {
    return 'Null{}';
  }
}

class _NullReader extends fb.TableReader<Null> {
  const _NullReader();

  @override
  Null createObject(fb.BufferContext bc, int offset) => 
    Null._(bc, offset);
}

class NullObjectBuilder extends fb.ObjectBuilder {

  NullObjectBuilder();

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    fbBuilder.startTable(0);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}
///  A Struct_ in the flatbuffer metadata is the same as an Arrow Struct
///  (according to the physical memory layout). We used Struct_ here as
///  Struct is a reserved word in Flatbuffers
class Struct_ {
  Struct_._(this._bc, this._bcOffset);
  factory Struct_(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<Struct_> reader = _Struct_Reader();

  final fb.BufferContext _bc;
  final int _bcOffset;


  @override
  String toString() {
    return 'Struct_{}';
  }
}

class _Struct_Reader extends fb.TableReader<Struct_> {
  const _Struct_Reader();

  @override
  Struct_ createObject(fb.BufferContext bc, int offset) => 
    Struct_._(bc, offset);
}

class Struct_ObjectBuilder extends fb.ObjectBuilder {

  Struct_ObjectBuilder();

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    fbBuilder.startTable(0);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}
class List {
  List._(this._bc, this._bcOffset);
  factory List(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<List> reader = _ListReader();

  final fb.BufferContext _bc;
  final int _bcOffset;


  @override
  String toString() {
    return 'List{}';
  }
}

class _ListReader extends fb.TableReader<List> {
  const _ListReader();

  @override
  List createObject(fb.BufferContext bc, int offset) => 
    List._(bc, offset);
}

class ListObjectBuilder extends fb.ObjectBuilder {

  ListObjectBuilder();

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    fbBuilder.startTable(0);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}
///  Same as List, but with 64-bit offsets, allowing to represent
///  extremely large data values.
class LargeList {
  LargeList._(this._bc, this._bcOffset);
  factory LargeList(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<LargeList> reader = _LargeListReader();

  final fb.BufferContext _bc;
  final int _bcOffset;


  @override
  String toString() {
    return 'LargeList{}';
  }
}

class _LargeListReader extends fb.TableReader<LargeList> {
  const _LargeListReader();

  @override
  LargeList createObject(fb.BufferContext bc, int offset) => 
    LargeList._(bc, offset);
}

class LargeListObjectBuilder extends fb.ObjectBuilder {

  LargeListObjectBuilder();

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    fbBuilder.startTable(0);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}
class FixedSizeList {
  FixedSizeList._(this._bc, this._bcOffset);
  factory FixedSizeList(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<FixedSizeList> reader = _FixedSizeListReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  ///  Number of list items per value
  int get listSize => const fb.Int32Reader().vTableGet(_bc, _bcOffset, 4, 0);

  @override
  String toString() {
    return 'FixedSizeList{listSize: $listSize}';
  }
}

class _FixedSizeListReader extends fb.TableReader<FixedSizeList> {
  const _FixedSizeListReader();

  @override
  FixedSizeList createObject(fb.BufferContext bc, int offset) => 
    FixedSizeList._(bc, offset);
}

class FixedSizeListBuilder {
  FixedSizeListBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  void begin() {
    fbBuilder.startTable(1);
  }

  int addListSize(int? listSize) {
    fbBuilder.addInt32(0, listSize);
    return fbBuilder.offset;
  }

  int finish() {
    return fbBuilder.endTable();
  }
}

class FixedSizeListObjectBuilder extends fb.ObjectBuilder {
  final int? _listSize;

  FixedSizeListObjectBuilder({
    int? listSize,
  })
      : _listSize = listSize;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    fbBuilder.startTable(1);
    fbBuilder.addInt32(0, _listSize);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}
///  A Map is a logical nested type that is represented as
/// 
///  List<entries: Struct<key: K, value: V>>
/// 
///  In this layout, the keys and values are each respectively contiguous. We do
///  not constrain the key and value types, so the application is responsible
///  for ensuring that the keys are hashable and unique. Whether the keys are sorted
///  may be set in the metadata for this field.
/// 
///  In a field with Map type, the field has a child Struct field, which then
///  has two children: key type and the second the value type. The names of the
///  child fields may be respectively "entries", "key", and "value", but this is
///  not enforced.
/// 
///  Map
///  ```text
///    - child[0] entries: Struct
///      - child[0] key: K
///      - child[1] value: V
///  ```
///  Neither the "entries" field nor the "key" field may be nullable.
/// 
///  The metadata is structured so that Arrow systems without special handling
///  for Map can make Map an alias for List. The "layout" attribute for the Map
///  field must have the same contents as a List.
class Map {
  Map._(this._bc, this._bcOffset);
  factory Map(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<Map> reader = _MapReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  ///  Set to true if the keys within each value are sorted
  bool get keysSorted => const fb.BoolReader().vTableGet(_bc, _bcOffset, 4, false);

  @override
  String toString() {
    return 'Map{keysSorted: $keysSorted}';
  }
}

class _MapReader extends fb.TableReader<Map> {
  const _MapReader();

  @override
  Map createObject(fb.BufferContext bc, int offset) => 
    Map._(bc, offset);
}

class MapBuilder {
  MapBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  void begin() {
    fbBuilder.startTable(1);
  }

  int addKeysSorted(bool? keysSorted) {
    fbBuilder.addBool(0, keysSorted);
    return fbBuilder.offset;
  }

  int finish() {
    return fbBuilder.endTable();
  }
}

class MapObjectBuilder extends fb.ObjectBuilder {
  final bool? _keysSorted;

  MapObjectBuilder({
    bool? keysSorted,
  })
      : _keysSorted = keysSorted;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    fbBuilder.startTable(1);
    fbBuilder.addBool(0, _keysSorted);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}
///  A union is a complex type with children in Field
///  By default ids in the type vector refer to the offsets in the children
///  optionally typeIds provides an indirection between the child offset and the type id
///  for each child `typeIds[offset]` is the id used in the type vector
class Union {
  Union._(this._bc, this._bcOffset);
  factory Union(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<Union> reader = _UnionReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  UnionMode get mode => UnionMode.fromValue(const fb.Int16Reader().vTableGet(_bc, _bcOffset, 4, 0));
  List<int>? get typeIds => const fb.ListReader<int>(fb.Int32Reader()).vTableGetNullable(_bc, _bcOffset, 6);

  @override
  String toString() {
    return 'Union{mode: $mode, typeIds: $typeIds}';
  }
}

class _UnionReader extends fb.TableReader<Union> {
  const _UnionReader();

  @override
  Union createObject(fb.BufferContext bc, int offset) => 
    Union._(bc, offset);
}

class UnionBuilder {
  UnionBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  void begin() {
    fbBuilder.startTable(2);
  }

  int addMode(UnionMode? mode) {
    fbBuilder.addInt16(0, mode?.value);
    return fbBuilder.offset;
  }
  int addTypeIdsOffset(int? offset) {
    fbBuilder.addOffset(1, offset);
    return fbBuilder.offset;
  }

  int finish() {
    return fbBuilder.endTable();
  }
}

class UnionObjectBuilder extends fb.ObjectBuilder {
  final UnionMode? _mode;
  final List<int>? _typeIds;

  UnionObjectBuilder({
    UnionMode? mode,
    List<int>? typeIds,
  })
      : _mode = mode,
        _typeIds = typeIds;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    final int? typeIdsOffset = _typeIds == null ? null
        : fbBuilder.writeListInt32(_typeIds!);
    fbBuilder.startTable(2);
    fbBuilder.addInt16(0, _mode?.value);
    fbBuilder.addOffset(1, typeIdsOffset);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}
class Int {
  Int._(this._bc, this._bcOffset);
  factory Int(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<Int> reader = _IntReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  int get bitWidth => const fb.Int32Reader().vTableGet(_bc, _bcOffset, 4, 0);
  bool get isSigned => const fb.BoolReader().vTableGet(_bc, _bcOffset, 6, false);

  @override
  String toString() {
    return 'Int{bitWidth: $bitWidth, isSigned: $isSigned}';
  }
}

class _IntReader extends fb.TableReader<Int> {
  const _IntReader();

  @override
  Int createObject(fb.BufferContext bc, int offset) => 
    Int._(bc, offset);
}

class IntBuilder {
  IntBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  void begin() {
    fbBuilder.startTable(2);
  }

  int addBitWidth(int? bitWidth) {
    fbBuilder.addInt32(0, bitWidth);
    return fbBuilder.offset;
  }
  int addIsSigned(bool? isSigned) {
    fbBuilder.addBool(1, isSigned);
    return fbBuilder.offset;
  }

  int finish() {
    return fbBuilder.endTable();
  }
}

class IntObjectBuilder extends fb.ObjectBuilder {
  final int? _bitWidth;
  final bool? _isSigned;

  IntObjectBuilder({
    int? bitWidth,
    bool? isSigned,
  })
      : _bitWidth = bitWidth,
        _isSigned = isSigned;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    fbBuilder.startTable(2);
    fbBuilder.addInt32(0, _bitWidth);
    fbBuilder.addBool(1, _isSigned);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}
class FloatingPoint {
  FloatingPoint._(this._bc, this._bcOffset);
  factory FloatingPoint(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<FloatingPoint> reader = _FloatingPointReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  Precision get precision => Precision.fromValue(const fb.Int16Reader().vTableGet(_bc, _bcOffset, 4, 0));

  @override
  String toString() {
    return 'FloatingPoint{precision: $precision}';
  }
}

class _FloatingPointReader extends fb.TableReader<FloatingPoint> {
  const _FloatingPointReader();

  @override
  FloatingPoint createObject(fb.BufferContext bc, int offset) => 
    FloatingPoint._(bc, offset);
}

class FloatingPointBuilder {
  FloatingPointBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  void begin() {
    fbBuilder.startTable(1);
  }

  int addPrecision(Precision? precision) {
    fbBuilder.addInt16(0, precision?.value);
    return fbBuilder.offset;
  }

  int finish() {
    return fbBuilder.endTable();
  }
}

class FloatingPointObjectBuilder extends fb.ObjectBuilder {
  final Precision? _precision;

  FloatingPointObjectBuilder({
    Precision? precision,
  })
      : _precision = precision;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    fbBuilder.startTable(1);
    fbBuilder.addInt16(0, _precision?.value);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}
///  Unicode with UTF-8 encoding
class Utf8 {
  Utf8._(this._bc, this._bcOffset);
  factory Utf8(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<Utf8> reader = _Utf8Reader();

  final fb.BufferContext _bc;
  final int _bcOffset;


  @override
  String toString() {
    return 'Utf8{}';
  }
}

class _Utf8Reader extends fb.TableReader<Utf8> {
  const _Utf8Reader();

  @override
  Utf8 createObject(fb.BufferContext bc, int offset) => 
    Utf8._(bc, offset);
}

class Utf8ObjectBuilder extends fb.ObjectBuilder {

  Utf8ObjectBuilder();

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    fbBuilder.startTable(0);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}
///  Opaque binary data
class Binary {
  Binary._(this._bc, this._bcOffset);
  factory Binary(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<Binary> reader = _BinaryReader();

  final fb.BufferContext _bc;
  final int _bcOffset;


  @override
  String toString() {
    return 'Binary{}';
  }
}

class _BinaryReader extends fb.TableReader<Binary> {
  const _BinaryReader();

  @override
  Binary createObject(fb.BufferContext bc, int offset) => 
    Binary._(bc, offset);
}

class BinaryObjectBuilder extends fb.ObjectBuilder {

  BinaryObjectBuilder();

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    fbBuilder.startTable(0);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}
///  Same as Utf8, but with 64-bit offsets, allowing to represent
///  extremely large data values.
class LargeUtf8 {
  LargeUtf8._(this._bc, this._bcOffset);
  factory LargeUtf8(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<LargeUtf8> reader = _LargeUtf8Reader();

  final fb.BufferContext _bc;
  final int _bcOffset;


  @override
  String toString() {
    return 'LargeUtf8{}';
  }
}

class _LargeUtf8Reader extends fb.TableReader<LargeUtf8> {
  const _LargeUtf8Reader();

  @override
  LargeUtf8 createObject(fb.BufferContext bc, int offset) => 
    LargeUtf8._(bc, offset);
}

class LargeUtf8ObjectBuilder extends fb.ObjectBuilder {

  LargeUtf8ObjectBuilder();

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    fbBuilder.startTable(0);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}
///  Same as Binary, but with 64-bit offsets, allowing to represent
///  extremely large data values.
class LargeBinary {
  LargeBinary._(this._bc, this._bcOffset);
  factory LargeBinary(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<LargeBinary> reader = _LargeBinaryReader();

  final fb.BufferContext _bc;
  final int _bcOffset;


  @override
  String toString() {
    return 'LargeBinary{}';
  }
}

class _LargeBinaryReader extends fb.TableReader<LargeBinary> {
  const _LargeBinaryReader();

  @override
  LargeBinary createObject(fb.BufferContext bc, int offset) => 
    LargeBinary._(bc, offset);
}

class LargeBinaryObjectBuilder extends fb.ObjectBuilder {

  LargeBinaryObjectBuilder();

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    fbBuilder.startTable(0);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}
class FixedSizeBinary {
  FixedSizeBinary._(this._bc, this._bcOffset);
  factory FixedSizeBinary(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<FixedSizeBinary> reader = _FixedSizeBinaryReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  ///  Number of bytes per value
  int get byteWidth => const fb.Int32Reader().vTableGet(_bc, _bcOffset, 4, 0);

  @override
  String toString() {
    return 'FixedSizeBinary{byteWidth: $byteWidth}';
  }
}

class _FixedSizeBinaryReader extends fb.TableReader<FixedSizeBinary> {
  const _FixedSizeBinaryReader();

  @override
  FixedSizeBinary createObject(fb.BufferContext bc, int offset) => 
    FixedSizeBinary._(bc, offset);
}

class FixedSizeBinaryBuilder {
  FixedSizeBinaryBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  void begin() {
    fbBuilder.startTable(1);
  }

  int addByteWidth(int? byteWidth) {
    fbBuilder.addInt32(0, byteWidth);
    return fbBuilder.offset;
  }

  int finish() {
    return fbBuilder.endTable();
  }
}

class FixedSizeBinaryObjectBuilder extends fb.ObjectBuilder {
  final int? _byteWidth;

  FixedSizeBinaryObjectBuilder({
    int? byteWidth,
  })
      : _byteWidth = byteWidth;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    fbBuilder.startTable(1);
    fbBuilder.addInt32(0, _byteWidth);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}
class Bool {
  Bool._(this._bc, this._bcOffset);
  factory Bool(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<Bool> reader = _BoolReader();

  final fb.BufferContext _bc;
  final int _bcOffset;


  @override
  String toString() {
    return 'Bool{}';
  }
}

class _BoolReader extends fb.TableReader<Bool> {
  const _BoolReader();

  @override
  Bool createObject(fb.BufferContext bc, int offset) => 
    Bool._(bc, offset);
}

class BoolObjectBuilder extends fb.ObjectBuilder {

  BoolObjectBuilder();

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    fbBuilder.startTable(0);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}
///  Exact decimal value represented as an integer value in two's
///  complement. Currently only 128-bit (16-byte) and 256-bit (32-byte) integers
///  are used. The representation uses the endianness indicated
///  in the Schema.
class Decimal {
  Decimal._(this._bc, this._bcOffset);
  factory Decimal(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<Decimal> reader = _DecimalReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  ///  Total number of decimal digits
  int get precision => const fb.Int32Reader().vTableGet(_bc, _bcOffset, 4, 0);
  ///  Number of digits after the decimal point "."
  int get scale => const fb.Int32Reader().vTableGet(_bc, _bcOffset, 6, 0);
  ///  Number of bits per value. The only accepted widths are 128 and 256.
  ///  We use bitWidth for consistency with Int::bitWidth.
  int get bitWidth => const fb.Int32Reader().vTableGet(_bc, _bcOffset, 8, 128);

  @override
  String toString() {
    return 'Decimal{precision: $precision, scale: $scale, bitWidth: $bitWidth}';
  }
}

class _DecimalReader extends fb.TableReader<Decimal> {
  const _DecimalReader();

  @override
  Decimal createObject(fb.BufferContext bc, int offset) => 
    Decimal._(bc, offset);
}

class DecimalBuilder {
  DecimalBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  void begin() {
    fbBuilder.startTable(3);
  }

  int addPrecision(int? precision) {
    fbBuilder.addInt32(0, precision);
    return fbBuilder.offset;
  }
  int addScale(int? scale) {
    fbBuilder.addInt32(1, scale);
    return fbBuilder.offset;
  }
  int addBitWidth(int? bitWidth) {
    fbBuilder.addInt32(2, bitWidth);
    return fbBuilder.offset;
  }

  int finish() {
    return fbBuilder.endTable();
  }
}

class DecimalObjectBuilder extends fb.ObjectBuilder {
  final int? _precision;
  final int? _scale;
  final int? _bitWidth;

  DecimalObjectBuilder({
    int? precision,
    int? scale,
    int? bitWidth,
  })
      : _precision = precision,
        _scale = scale,
        _bitWidth = bitWidth;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    fbBuilder.startTable(3);
    fbBuilder.addInt32(0, _precision);
    fbBuilder.addInt32(1, _scale);
    fbBuilder.addInt32(2, _bitWidth);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}
///  Date is either a 32-bit or 64-bit signed integer type representing an
///  elapsed time since UNIX epoch (1970-01-01), stored in either of two units:
/// 
///  * Milliseconds (64 bits) indicating UNIX time elapsed since the epoch (no
///    leap seconds), where the values are evenly divisible by 86400000
///  * Days (32 bits) since the UNIX epoch
class Date {
  Date._(this._bc, this._bcOffset);
  factory Date(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<Date> reader = _DateReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  DateUnit get unit => DateUnit.fromValue(const fb.Int16Reader().vTableGet(_bc, _bcOffset, 4, 1));

  @override
  String toString() {
    return 'Date{unit: $unit}';
  }
}

class _DateReader extends fb.TableReader<Date> {
  const _DateReader();

  @override
  Date createObject(fb.BufferContext bc, int offset) => 
    Date._(bc, offset);
}

class DateBuilder {
  DateBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  void begin() {
    fbBuilder.startTable(1);
  }

  int addUnit(DateUnit? unit) {
    fbBuilder.addInt16(0, unit?.value);
    return fbBuilder.offset;
  }

  int finish() {
    return fbBuilder.endTable();
  }
}

class DateObjectBuilder extends fb.ObjectBuilder {
  final DateUnit? _unit;

  DateObjectBuilder({
    DateUnit? unit,
  })
      : _unit = unit;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    fbBuilder.startTable(1);
    fbBuilder.addInt16(0, _unit?.value);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}
///  Time is either a 32-bit or 64-bit signed integer type representing an
///  elapsed time since midnight, stored in either of four units: seconds,
///  milliseconds, microseconds or nanoseconds.
/// 
///  The integer `bitWidth` depends on the `unit` and must be one of the following:
///  * SECOND and MILLISECOND: 32 bits
///  * MICROSECOND and NANOSECOND: 64 bits
/// 
///  The allowed values are between 0 (inclusive) and 86400 (=24*60*60) seconds
///  (exclusive), adjusted for the time unit (for example, up to 86400000
///  exclusive for the MILLISECOND unit).
///  This definition doesn't allow for leap seconds. Time values from
///  measurements with leap seconds will need to be corrected when ingesting
///  into Arrow (for example by replacing the value 86400 with 86399).
class Time {
  Time._(this._bc, this._bcOffset);
  factory Time(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<Time> reader = _TimeReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  TimeUnit get unit => TimeUnit.fromValue(const fb.Int16Reader().vTableGet(_bc, _bcOffset, 4, 1));
  int get bitWidth => const fb.Int32Reader().vTableGet(_bc, _bcOffset, 6, 32);

  @override
  String toString() {
    return 'Time{unit: $unit, bitWidth: $bitWidth}';
  }
}

class _TimeReader extends fb.TableReader<Time> {
  const _TimeReader();

  @override
  Time createObject(fb.BufferContext bc, int offset) => 
    Time._(bc, offset);
}

class TimeBuilder {
  TimeBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  void begin() {
    fbBuilder.startTable(2);
  }

  int addUnit(TimeUnit? unit) {
    fbBuilder.addInt16(0, unit?.value);
    return fbBuilder.offset;
  }
  int addBitWidth(int? bitWidth) {
    fbBuilder.addInt32(1, bitWidth);
    return fbBuilder.offset;
  }

  int finish() {
    return fbBuilder.endTable();
  }
}

class TimeObjectBuilder extends fb.ObjectBuilder {
  final TimeUnit? _unit;
  final int? _bitWidth;

  TimeObjectBuilder({
    TimeUnit? unit,
    int? bitWidth,
  })
      : _unit = unit,
        _bitWidth = bitWidth;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    fbBuilder.startTable(2);
    fbBuilder.addInt16(0, _unit?.value);
    fbBuilder.addInt32(1, _bitWidth);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}
///  Timestamp is a 64-bit signed integer representing an elapsed time since a
///  fixed epoch, stored in either of four units: seconds, milliseconds,
///  microseconds or nanoseconds, and is optionally annotated with a timezone.
/// 
///  Timestamp values do not include any leap seconds (in other words, all
///  days are considered 86400 seconds long).
/// 
///  Timestamps with a non-empty timezone
///  ------------------------------------
/// 
///  If a Timestamp column has a non-empty timezone value, its epoch is
///  1970-01-01 00:00:00 (January 1st 1970, midnight) in the *UTC* timezone
///  (the Unix epoch), regardless of the Timestamp's own timezone.
/// 
///  Therefore, timestamp values with a non-empty timezone correspond to
///  physical points in time together with some additional information about
///  how the data was obtained and/or how to display it (the timezone).
/// 
///    For example, the timestamp value 0 with the timezone string "Europe/Paris"
///    corresponds to "January 1st 1970, 00h00" in the UTC timezone, but the
///    application may prefer to display it as "January 1st 1970, 01h00" in
///    the Europe/Paris timezone (which is the same physical point in time).
/// 
///  One consequence is that timestamp values with a non-empty timezone
///  can be compared and ordered directly, since they all share the same
///  well-known point of reference (the Unix epoch).
/// 
///  Timestamps with an unset / empty timezone
///  -----------------------------------------
/// 
///  If a Timestamp column has no timezone value, its epoch is
///  1970-01-01 00:00:00 (January 1st 1970, midnight) in an *unknown* timezone.
/// 
///  Therefore, timestamp values without a timezone cannot be meaningfully
///  interpreted as physical points in time, but only as calendar / clock
///  indications ("wall clock time") in an unspecified timezone.
/// 
///    For example, the timestamp value 0 with an empty timezone string
///    corresponds to "January 1st 1970, 00h00" in an unknown timezone: there
///    is not enough information to interpret it as a well-defined physical
///    point in time.
/// 
///  One consequence is that timestamp values without a timezone cannot
///  be reliably compared or ordered, since they may have different points of
///  reference.  In particular, it is *not* possible to interpret an unset
///  or empty timezone as the same as "UTC".
/// 
///  Conversion between timezones
///  ----------------------------
/// 
///  If a Timestamp column has a non-empty timezone, changing the timezone
///  to a different non-empty value is a metadata-only operation:
///  the timestamp values need not change as their point of reference remains
///  the same (the Unix epoch).
/// 
///  However, if a Timestamp column has no timezone value, changing it to a
///  non-empty value requires to think about the desired semantics.
///  One possibility is to assume that the original timestamp values are
///  relative to the epoch of the timezone being set; timestamp values should
///  then adjusted to the Unix epoch (for example, changing the timezone from
///  empty to "Europe/Paris" would require converting the timestamp values
///  from "Europe/Paris" to "UTC", which seems counter-intuitive but is
///  nevertheless correct).
/// 
///  Guidelines for encoding data from external libraries
///  ----------------------------------------------------
/// 
///  Date & time libraries often have multiple different data types for temporal
///  data. In order to ease interoperability between different implementations the
///  Arrow project has some recommendations for encoding these types into a Timestamp
///  column.
/// 
///  An "instant" represents a physical point in time that has no relevant timezone
///  (for example, astronomical data). To encode an instant, use a Timestamp with
///  the timezone string set to "UTC", and make sure the Timestamp values
///  are relative to the UTC epoch (January 1st 1970, midnight).
/// 
///  A "zoned date-time" represents a physical point in time annotated with an
///  informative timezone (for example, the timezone in which the data was
///  recorded).  To encode a zoned date-time, use a Timestamp with the timezone
///  string set to the name of the timezone, and make sure the Timestamp values
///  are relative to the UTC epoch (January 1st 1970, midnight).
/// 
///   (There is some ambiguity between an instant and a zoned date-time with the
///    UTC timezone.  Both of these are stored the same in Arrow.  Typically,
///    this distinction does not matter.  If it does, then an application should
///    use custom metadata or an extension type to distinguish between the two cases.)
/// 
///  An "offset date-time" represents a physical point in time combined with an
///  explicit offset from UTC.  To encode an offset date-time, use a Timestamp
///  with the timezone string set to the numeric timezone offset string
///  (e.g. "+03:00"), and make sure the Timestamp values are relative to
///  the UTC epoch (January 1st 1970, midnight).
/// 
///  A "naive date-time" (also called "local date-time" in some libraries)
///  represents a wall clock time combined with a calendar date, but with
///  no indication of how to map this information to a physical point in time.
///  Naive date-times must be handled with care because of this missing
///  information, and also because daylight saving time (DST) may make
///  some values ambiguous or non-existent. A naive date-time may be
///  stored as a struct with Date and Time fields. However, it may also be
///  encoded into a Timestamp column with an empty timezone. The timestamp
///  values should be computed "as if" the timezone of the date-time values
///  was UTC; for example, the naive date-time "January 1st 1970, 00h00" would
///  be encoded as timestamp value 0.
class Timestamp {
  Timestamp._(this._bc, this._bcOffset);
  factory Timestamp(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<Timestamp> reader = _TimestampReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  TimeUnit get unit => TimeUnit.fromValue(const fb.Int16Reader().vTableGet(_bc, _bcOffset, 4, 0));
  ///  The timezone is an optional string indicating the name of a timezone,
  ///  one of:
  /// 
  ///  * As used in the Olson timezone database (the "tz database" or
  ///    "tzdata"), such as "America/New_York".
  ///  * An absolute timezone offset of the form "+XX:XX" or "-XX:XX",
  ///    such as "+07:30".
  /// 
  ///  Whether a timezone string is present indicates different semantics about
  ///  the data (see above).
  String? get timezone => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 6);

  @override
  String toString() {
    return 'Timestamp{unit: $unit, timezone: $timezone}';
  }
}

class _TimestampReader extends fb.TableReader<Timestamp> {
  const _TimestampReader();

  @override
  Timestamp createObject(fb.BufferContext bc, int offset) => 
    Timestamp._(bc, offset);
}

class TimestampBuilder {
  TimestampBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  void begin() {
    fbBuilder.startTable(2);
  }

  int addUnit(TimeUnit? unit) {
    fbBuilder.addInt16(0, unit?.value);
    return fbBuilder.offset;
  }
  int addTimezoneOffset(int? offset) {
    fbBuilder.addOffset(1, offset);
    return fbBuilder.offset;
  }

  int finish() {
    return fbBuilder.endTable();
  }
}

class TimestampObjectBuilder extends fb.ObjectBuilder {
  final TimeUnit? _unit;
  final String? _timezone;

  TimestampObjectBuilder({
    TimeUnit? unit,
    String? timezone,
  })
      : _unit = unit,
        _timezone = timezone;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    final int? timezoneOffset = _timezone == null ? null
        : fbBuilder.writeString(_timezone!);
    fbBuilder.startTable(2);
    fbBuilder.addInt16(0, _unit?.value);
    fbBuilder.addOffset(1, timezoneOffset);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}
class Interval {
  Interval._(this._bc, this._bcOffset);
  factory Interval(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<Interval> reader = _IntervalReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  IntervalUnit get unit => IntervalUnit.fromValue(const fb.Int16Reader().vTableGet(_bc, _bcOffset, 4, 0));

  @override
  String toString() {
    return 'Interval{unit: $unit}';
  }
}

class _IntervalReader extends fb.TableReader<Interval> {
  const _IntervalReader();

  @override
  Interval createObject(fb.BufferContext bc, int offset) => 
    Interval._(bc, offset);
}

class IntervalBuilder {
  IntervalBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  void begin() {
    fbBuilder.startTable(1);
  }

  int addUnit(IntervalUnit? unit) {
    fbBuilder.addInt16(0, unit?.value);
    return fbBuilder.offset;
  }

  int finish() {
    return fbBuilder.endTable();
  }
}

class IntervalObjectBuilder extends fb.ObjectBuilder {
  final IntervalUnit? _unit;

  IntervalObjectBuilder({
    IntervalUnit? unit,
  })
      : _unit = unit;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    fbBuilder.startTable(1);
    fbBuilder.addInt16(0, _unit?.value);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}
class Duration {
  Duration._(this._bc, this._bcOffset);
  factory Duration(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<Duration> reader = _DurationReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  TimeUnit get unit => TimeUnit.fromValue(const fb.Int16Reader().vTableGet(_bc, _bcOffset, 4, 1));

  @override
  String toString() {
    return 'Duration{unit: $unit}';
  }
}

class _DurationReader extends fb.TableReader<Duration> {
  const _DurationReader();

  @override
  Duration createObject(fb.BufferContext bc, int offset) => 
    Duration._(bc, offset);
}

class DurationBuilder {
  DurationBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  void begin() {
    fbBuilder.startTable(1);
  }

  int addUnit(TimeUnit? unit) {
    fbBuilder.addInt16(0, unit?.value);
    return fbBuilder.offset;
  }

  int finish() {
    return fbBuilder.endTable();
  }
}

class DurationObjectBuilder extends fb.ObjectBuilder {
  final TimeUnit? _unit;

  DurationObjectBuilder({
    TimeUnit? unit,
  })
      : _unit = unit;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    fbBuilder.startTable(1);
    fbBuilder.addInt16(0, _unit?.value);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}
///  ----------------------------------------------------------------------
///  user defined key value pairs to add custom metadata to arrow
///  key namespacing is the responsibility of the user
class KeyValue {
  KeyValue._(this._bc, this._bcOffset);
  factory KeyValue(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<KeyValue> reader = _KeyValueReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  String? get key => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 4);
  String? get value => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 6);

  @override
  String toString() {
    return 'KeyValue{key: $key, value: $value}';
  }
}

class _KeyValueReader extends fb.TableReader<KeyValue> {
  const _KeyValueReader();

  @override
  KeyValue createObject(fb.BufferContext bc, int offset) => 
    KeyValue._(bc, offset);
}

class KeyValueBuilder {
  KeyValueBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  void begin() {
    fbBuilder.startTable(2);
  }

  int addKeyOffset(int? offset) {
    fbBuilder.addOffset(0, offset);
    return fbBuilder.offset;
  }
  int addValueOffset(int? offset) {
    fbBuilder.addOffset(1, offset);
    return fbBuilder.offset;
  }

  int finish() {
    return fbBuilder.endTable();
  }
}

class KeyValueObjectBuilder extends fb.ObjectBuilder {
  final String? _key;
  final String? _value;

  KeyValueObjectBuilder({
    String? key,
    String? value,
  })
      : _key = key,
        _value = value;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    final int? keyOffset = _key == null ? null
        : fbBuilder.writeString(_key!);
    final int? valueOffset = _value == null ? null
        : fbBuilder.writeString(_value!);
    fbBuilder.startTable(2);
    fbBuilder.addOffset(0, keyOffset);
    fbBuilder.addOffset(1, valueOffset);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}
class DictionaryEncoding {
  DictionaryEncoding._(this._bc, this._bcOffset);
  factory DictionaryEncoding(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<DictionaryEncoding> reader = _DictionaryEncodingReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  ///  The known dictionary id in the application where this data is used. In
  ///  the file or streaming formats, the dictionary ids are found in the
  ///  DictionaryBatch messages
  int get id => const fb.Int64Reader().vTableGet(_bc, _bcOffset, 4, 0);
  ///  The dictionary indices are constrained to be non-negative integers. If
  ///  this field is null, the indices must be signed int32. To maximize
  ///  cross-language compatibility and performance, implementations are
  ///  recommended to prefer signed integer types over unsigned integer types
  ///  and to avoid uint64 indices unless they are required by an application.
  Int? get indexType => Int.reader.vTableGetNullable(_bc, _bcOffset, 6);
  ///  By default, dictionaries are not ordered, or the order does not have
  ///  semantic meaning. In some statistical, applications, dictionary-encoding
  ///  is used to represent ordered categorical data, and we provide a way to
  ///  preserve that metadata here
  bool get isOrdered => const fb.BoolReader().vTableGet(_bc, _bcOffset, 8, false);
  DictionaryKind get dictionaryKind => DictionaryKind.fromValue(const fb.Int16Reader().vTableGet(_bc, _bcOffset, 10, 0));

  @override
  String toString() {
    return 'DictionaryEncoding{id: $id, indexType: $indexType, isOrdered: $isOrdered, dictionaryKind: $dictionaryKind}';
  }
}

class _DictionaryEncodingReader extends fb.TableReader<DictionaryEncoding> {
  const _DictionaryEncodingReader();

  @override
  DictionaryEncoding createObject(fb.BufferContext bc, int offset) => 
    DictionaryEncoding._(bc, offset);
}

class DictionaryEncodingBuilder {
  DictionaryEncodingBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  void begin() {
    fbBuilder.startTable(4);
  }

  int addId(int? id) {
    fbBuilder.addInt64(0, id);
    return fbBuilder.offset;
  }
  int addIndexTypeOffset(int? offset) {
    fbBuilder.addOffset(1, offset);
    return fbBuilder.offset;
  }
  int addIsOrdered(bool? isOrdered) {
    fbBuilder.addBool(2, isOrdered);
    return fbBuilder.offset;
  }
  int addDictionaryKind(DictionaryKind? dictionaryKind) {
    fbBuilder.addInt16(3, dictionaryKind?.value);
    return fbBuilder.offset;
  }

  int finish() {
    return fbBuilder.endTable();
  }
}

class DictionaryEncodingObjectBuilder extends fb.ObjectBuilder {
  final int? _id;
  final IntObjectBuilder? _indexType;
  final bool? _isOrdered;
  final DictionaryKind? _dictionaryKind;

  DictionaryEncodingObjectBuilder({
    int? id,
    IntObjectBuilder? indexType,
    bool? isOrdered,
    DictionaryKind? dictionaryKind,
  })
      : _id = id,
        _indexType = indexType,
        _isOrdered = isOrdered,
        _dictionaryKind = dictionaryKind;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    final int? indexTypeOffset = _indexType?.getOrCreateOffset(fbBuilder);
    fbBuilder.startTable(4);
    fbBuilder.addInt64(0, _id);
    fbBuilder.addOffset(1, indexTypeOffset);
    fbBuilder.addBool(2, _isOrdered);
    fbBuilder.addInt16(3, _dictionaryKind?.value);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}
///  ----------------------------------------------------------------------
///  A field represents a named column in a record / row batch or child of a
///  nested type.
class Field {
  Field._(this._bc, this._bcOffset);
  factory Field(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<Field> reader = _FieldReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  ///  Name is not required, in i.e. a List
  String? get name => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 4);
  ///  Whether or not this field can contain nulls. Should be true in general.
  bool get nullable => const fb.BoolReader().vTableGet(_bc, _bcOffset, 6, false);
  TypeTypeId? get typeType => TypeTypeId._createOrNull(const fb.Uint8Reader().vTableGetNullable(_bc, _bcOffset, 8));
  ///  This is the type of the decoded value if the field is dictionary encoded.
  dynamic get type {
    switch (typeType?.value) {
      case 1: return Null.reader.vTableGetNullable(_bc, _bcOffset, 10);
      case 2: return Int.reader.vTableGetNullable(_bc, _bcOffset, 10);
      case 3: return FloatingPoint.reader.vTableGetNullable(_bc, _bcOffset, 10);
      case 4: return Binary.reader.vTableGetNullable(_bc, _bcOffset, 10);
      case 5: return Utf8.reader.vTableGetNullable(_bc, _bcOffset, 10);
      case 6: return Bool.reader.vTableGetNullable(_bc, _bcOffset, 10);
      case 7: return Decimal.reader.vTableGetNullable(_bc, _bcOffset, 10);
      case 8: return Date.reader.vTableGetNullable(_bc, _bcOffset, 10);
      case 9: return Time.reader.vTableGetNullable(_bc, _bcOffset, 10);
      case 10: return Timestamp.reader.vTableGetNullable(_bc, _bcOffset, 10);
      case 11: return Interval.reader.vTableGetNullable(_bc, _bcOffset, 10);
      case 12: return List.reader.vTableGetNullable(_bc, _bcOffset, 10);
      case 13: return Struct_.reader.vTableGetNullable(_bc, _bcOffset, 10);
      case 14: return Union.reader.vTableGetNullable(_bc, _bcOffset, 10);
      case 15: return FixedSizeBinary.reader.vTableGetNullable(_bc, _bcOffset, 10);
      case 16: return FixedSizeList.reader.vTableGetNullable(_bc, _bcOffset, 10);
      case 17: return Map.reader.vTableGetNullable(_bc, _bcOffset, 10);
      case 18: return Duration.reader.vTableGetNullable(_bc, _bcOffset, 10);
      case 19: return LargeBinary.reader.vTableGetNullable(_bc, _bcOffset, 10);
      case 20: return LargeUtf8.reader.vTableGetNullable(_bc, _bcOffset, 10);
      case 21: return LargeList.reader.vTableGetNullable(_bc, _bcOffset, 10);
      default: return null;
    }
  }
  ///  Present only if the field is dictionary encoded.
  DictionaryEncoding? get dictionary => DictionaryEncoding.reader.vTableGetNullable(_bc, _bcOffset, 12);
  ///  children apply only to nested data types like Struct, List and Union. For
  ///  primitive types children will have length 0.
  List<Field>? get children => const fb.ListReader<Field>(Field.reader).vTableGetNullable(_bc, _bcOffset, 14);
  ///  User-defined metadata
  List<KeyValue>? get customMetadata => const fb.ListReader<KeyValue>(KeyValue.reader).vTableGetNullable(_bc, _bcOffset, 16);

  @override
  String toString() {
    return 'Field{name: $name, nullable: $nullable, typeType: $typeType, type: $type, dictionary: $dictionary, children: $children, customMetadata: $customMetadata}';
  }
}

class _FieldReader extends fb.TableReader<Field> {
  const _FieldReader();

  @override
  Field createObject(fb.BufferContext bc, int offset) => 
    Field._(bc, offset);
}

class FieldBuilder {
  FieldBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  void begin() {
    fbBuilder.startTable(7);
  }

  int addNameOffset(int? offset) {
    fbBuilder.addOffset(0, offset);
    return fbBuilder.offset;
  }
  int addNullable(bool? nullable) {
    fbBuilder.addBool(1, nullable);
    return fbBuilder.offset;
  }
  int addTypeType(TypeTypeId? typeType) {
    fbBuilder.addUint8(2, typeType?.value);
    return fbBuilder.offset;
  }
  int addTypeOffset(int? offset) {
    fbBuilder.addOffset(3, offset);
    return fbBuilder.offset;
  }
  int addDictionaryOffset(int? offset) {
    fbBuilder.addOffset(4, offset);
    return fbBuilder.offset;
  }
  int addChildrenOffset(int? offset) {
    fbBuilder.addOffset(5, offset);
    return fbBuilder.offset;
  }
  int addCustomMetadataOffset(int? offset) {
    fbBuilder.addOffset(6, offset);
    return fbBuilder.offset;
  }

  int finish() {
    return fbBuilder.endTable();
  }
}

class FieldObjectBuilder extends fb.ObjectBuilder {
  final String? _name;
  final bool? _nullable;
  final TypeTypeId? _typeType;
  final dynamic _type;
  final DictionaryEncodingObjectBuilder? _dictionary;
  final List<FieldObjectBuilder>? _children;
  final List<KeyValueObjectBuilder>? _customMetadata;

  FieldObjectBuilder({
    String? name,
    bool? nullable,
    TypeTypeId? typeType,
    dynamic type,
    DictionaryEncodingObjectBuilder? dictionary,
    List<FieldObjectBuilder>? children,
    List<KeyValueObjectBuilder>? customMetadata,
  })
      : _name = name,
        _nullable = nullable,
        _typeType = typeType,
        _type = type,
        _dictionary = dictionary,
        _children = children,
        _customMetadata = customMetadata;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    final int? nameOffset = _name == null ? null
        : fbBuilder.writeString(_name!);
    final int? typeOffset = _type?.getOrCreateOffset(fbBuilder);
    final int? dictionaryOffset = _dictionary?.getOrCreateOffset(fbBuilder);
    final int? childrenOffset = _children == null ? null
        : fbBuilder.writeList(_children!.map((b) => b.getOrCreateOffset(fbBuilder)).toList());
    final int? customMetadataOffset = _customMetadata == null ? null
        : fbBuilder.writeList(_customMetadata!.map((b) => b.getOrCreateOffset(fbBuilder)).toList());
    fbBuilder.startTable(7);
    fbBuilder.addOffset(0, nameOffset);
    fbBuilder.addBool(1, _nullable);
    fbBuilder.addUint8(2, _typeType?.value);
    fbBuilder.addOffset(3, typeOffset);
    fbBuilder.addOffset(4, dictionaryOffset);
    fbBuilder.addOffset(5, childrenOffset);
    fbBuilder.addOffset(6, customMetadataOffset);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}
///  ----------------------------------------------------------------------
///  A Buffer represents a single contiguous memory segment
class Buffer {
  Buffer._(this._bc, this._bcOffset);

  static const fb.Reader<Buffer> reader = _BufferReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  ///  The relative offset into the shared memory page where the bytes for this
  ///  buffer starts
  int get offset => const fb.Int64Reader().read(_bc, _bcOffset + 0);
  ///  The absolute length (in bytes) of the memory buffer. The memory is found
  ///  from offset (inclusive) to offset + length (non-inclusive). When building
  ///  messages using the encapsulated IPC message, padding bytes may be written
  ///  after a buffer, but such padding bytes do not need to be accounted for in
  ///  the size here.
  int get length => const fb.Int64Reader().read(_bc, _bcOffset + 8);

  @override
  String toString() {
    return 'Buffer{offset: $offset, length: $length}';
  }
}

class _BufferReader extends fb.StructReader<Buffer> {
  const _BufferReader();

  @override
  int get size => 16;

  @override
  Buffer createObject(fb.BufferContext bc, int offset) => 
    Buffer._(bc, offset);
}

class BufferBuilder {
  BufferBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  int finish(int offset, int length) {
    fbBuilder.putInt64(length);
    fbBuilder.putInt64(offset);
    return fbBuilder.offset;
  }

}

class BufferObjectBuilder extends fb.ObjectBuilder {
  final int _offset;
  final int _length;

  BufferObjectBuilder({
    required int offset,
    required int length,
  })
      : _offset = offset,
        _length = length;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    fbBuilder.putInt64(_length);
    fbBuilder.putInt64(_offset);
    return fbBuilder.offset;
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}
///  ----------------------------------------------------------------------
///  A Schema describes the columns in a row batch
class Schema {
  Schema._(this._bc, this._bcOffset);
  factory Schema(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<Schema> reader = _SchemaReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  ///  endianness of the buffer
  ///  it is Little Endian by default
  ///  if endianness doesn't match the underlying system then the vectors need to be converted
  Endianness get endianness => Endianness.fromValue(const fb.Int16Reader().vTableGet(_bc, _bcOffset, 4, 0));
  List<Field>? get fields => const fb.ListReader<Field>(Field.reader).vTableGetNullable(_bc, _bcOffset, 6);
  List<KeyValue>? get customMetadata => const fb.ListReader<KeyValue>(KeyValue.reader).vTableGetNullable(_bc, _bcOffset, 8);
  ///  Features used in the stream/file.
  List<Feature>? get features => const fb.ListReader<Feature>(Feature.reader).vTableGetNullable(_bc, _bcOffset, 10);

  @override
  String toString() {
    return 'Schema{endianness: $endianness, fields: $fields, customMetadata: $customMetadata, features: $features}';
  }
}

class _SchemaReader extends fb.TableReader<Schema> {
  const _SchemaReader();

  @override
  Schema createObject(fb.BufferContext bc, int offset) => 
    Schema._(bc, offset);
}

class SchemaBuilder {
  SchemaBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  void begin() {
    fbBuilder.startTable(4);
  }

  int addEndianness(Endianness? endianness) {
    fbBuilder.addInt16(0, endianness?.value);
    return fbBuilder.offset;
  }
  int addFieldsOffset(int? offset) {
    fbBuilder.addOffset(1, offset);
    return fbBuilder.offset;
  }
  int addCustomMetadataOffset(int? offset) {
    fbBuilder.addOffset(2, offset);
    return fbBuilder.offset;
  }
  int addFeaturesOffset(int? offset) {
    fbBuilder.addOffset(3, offset);
    return fbBuilder.offset;
  }

  int finish() {
    return fbBuilder.endTable();
  }
}

class SchemaObjectBuilder extends fb.ObjectBuilder {
  final Endianness? _endianness;
  final List<FieldObjectBuilder>? _fields;
  final List<KeyValueObjectBuilder>? _customMetadata;
  final List<Feature>? _features;

  SchemaObjectBuilder({
    Endianness? endianness,
    List<FieldObjectBuilder>? fields,
    List<KeyValueObjectBuilder>? customMetadata,
    List<Feature>? features,
  })
      : _endianness = endianness,
        _fields = fields,
        _customMetadata = customMetadata,
        _features = features;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    final int? fieldsOffset = _fields == null ? null
        : fbBuilder.writeList(_fields!.map((b) => b.getOrCreateOffset(fbBuilder)).toList());
    final int? customMetadataOffset = _customMetadata == null ? null
        : fbBuilder.writeList(_customMetadata!.map((b) => b.getOrCreateOffset(fbBuilder)).toList());
    final int? featuresOffset = _features == null ? null
        : fbBuilder.writeListInt64(_features!.map((f) => f.value).toList());
    fbBuilder.startTable(4);
    fbBuilder.addInt16(0, _endianness?.value);
    fbBuilder.addOffset(1, fieldsOffset);
    fbBuilder.addOffset(2, customMetadataOffset);
    fbBuilder.addOffset(3, featuresOffset);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}
