// automatically generated by the FlatBuffers compiler, do not modify

package org.apache.arrow.flatbuf

import java.nio.*
import kotlin.math.sign
import com.google.flatbuffers.*

/**
 * Exact decimal value represented as an integer value in two's
 * complement. Currently only 128-bit (16-byte) and 256-bit (32-byte) integers
 * are used. The representation uses the endianness indicated
 * in the Schema.
 */
@Suppress("unused")
@ExperimentalUnsignedTypes
class Decimal : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : Decimal {
        __init(_i, _bb)
        return this
    }
    /**
     * Total number of decimal digits
     */
    val precision : Int
        get() {
            val o = __offset(4)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * Number of digits after the decimal point "."
     */
    val scale : Int
        get() {
            val o = __offset(6)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * Number of bits per value. The only accepted widths are 128 and 256.
     * We use bitWidth for consistency with Int::bitWidth.
     */
    val bitWidth : Int
        get() {
            val o = __offset(8)
            return if(o != 0) bb.getInt(o + bb_pos) else 128
        }
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_2_0_0()
        fun getRootAsDecimal(_bb: ByteBuffer): Decimal = getRootAsDecimal(_bb, Decimal())
        fun getRootAsDecimal(_bb: ByteBuffer, obj: Decimal): Decimal {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun createDecimal(builder: FlatBufferBuilder, precision: Int, scale: Int, bitWidth: Int) : Int {
            builder.startTable(3)
            addBitWidth(builder, bitWidth)
            addScale(builder, scale)
            addPrecision(builder, precision)
            return endDecimal(builder)
        }
        fun startDecimal(builder: FlatBufferBuilder) = builder.startTable(3)
        fun addPrecision(builder: FlatBufferBuilder, precision: Int) = builder.addInt(0, precision, 0)
        fun addScale(builder: FlatBufferBuilder, scale: Int) = builder.addInt(1, scale, 0)
        fun addBitWidth(builder: FlatBufferBuilder, bitWidth: Int) = builder.addInt(2, bitWidth, 128)
        fun endDecimal(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
    }
}
