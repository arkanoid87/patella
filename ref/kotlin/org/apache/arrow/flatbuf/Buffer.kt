// automatically generated by the FlatBuffers compiler, do not modify

package org.apache.arrow.flatbuf

import java.nio.*
import kotlin.math.sign
import com.google.flatbuffers.*

/**
 * ----------------------------------------------------------------------
 * A Buffer represents a single contiguous memory segment
 */
@Suppress("unused")
@ExperimentalUnsignedTypes
class Buffer : Struct() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : Buffer {
        __init(_i, _bb)
        return this
    }
    /**
     * The relative offset into the shared memory page where the bytes for this
     * buffer starts
     */
    val offset : Long get() = bb.getLong(bb_pos + 0)
    /**
     * The absolute length (in bytes) of the memory buffer. The memory is found
     * from offset (inclusive) to offset + length (non-inclusive). When building
     * messages using the encapsulated IPC message, padding bytes may be written
     * after a buffer, but such padding bytes do not need to be accounted for in
     * the size here.
     */
    val length : Long get() = bb.getLong(bb_pos + 8)
    companion object {
        fun createBuffer(builder: FlatBufferBuilder, offset: Long, length: Long) : Int {
            builder.prep(8, 16)
            builder.putLong(length)
            builder.putLong(offset)
            return builder.offset()
        }
    }
}
