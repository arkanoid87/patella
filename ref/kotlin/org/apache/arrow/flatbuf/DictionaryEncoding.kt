// automatically generated by the FlatBuffers compiler, do not modify

package org.apache.arrow.flatbuf

import java.nio.*
import kotlin.math.sign
import com.google.flatbuffers.*

@Suppress("unused")
@ExperimentalUnsignedTypes
class DictionaryEncoding : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : DictionaryEncoding {
        __init(_i, _bb)
        return this
    }
    /**
     * The known dictionary id in the application where this data is used. In
     * the file or streaming formats, the dictionary ids are found in the
     * DictionaryBatch messages
     */
    val id : Long
        get() {
            val o = __offset(4)
            return if(o != 0) bb.getLong(o + bb_pos) else 0L
        }
    /**
     * The dictionary indices are constrained to be non-negative integers. If
     * this field is null, the indices must be signed int32. To maximize
     * cross-language compatibility and performance, implementations are
     * recommended to prefer signed integer types over unsigned integer types
     * and to avoid uint64 indices unless they are required by an application.
     */
    val indexType : org.apache.arrow.flatbuf.Int? get() = indexType(org.apache.arrow.flatbuf.Int())
    fun indexType(obj: org.apache.arrow.flatbuf.Int) : org.apache.arrow.flatbuf.Int? {
        val o = __offset(6)
        return if (o != 0) {
            obj.__assign(__indirect(o + bb_pos), bb)
        } else {
            null
        }
    }
    /**
     * By default, dictionaries are not ordered, or the order does not have
     * semantic meaning. In some statistical, applications, dictionary-encoding
     * is used to represent ordered categorical data, and we provide a way to
     * preserve that metadata here
     */
    val isOrdered : Boolean
        get() {
            val o = __offset(8)
            return if(o != 0) 0.toByte() != bb.get(o + bb_pos) else false
        }
    val dictionaryKind : Short
        get() {
            val o = __offset(10)
            return if(o != 0) bb.getShort(o + bb_pos) else 0
        }
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_2_0_0()
        fun getRootAsDictionaryEncoding(_bb: ByteBuffer): DictionaryEncoding = getRootAsDictionaryEncoding(_bb, DictionaryEncoding())
        fun getRootAsDictionaryEncoding(_bb: ByteBuffer, obj: DictionaryEncoding): DictionaryEncoding {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun createDictionaryEncoding(builder: FlatBufferBuilder, id: Long, indexTypeOffset: Int, isOrdered: Boolean, dictionaryKind: Short) : Int {
            builder.startTable(4)
            addId(builder, id)
            addIndexType(builder, indexTypeOffset)
            addDictionaryKind(builder, dictionaryKind)
            addIsOrdered(builder, isOrdered)
            return endDictionaryEncoding(builder)
        }
        fun startDictionaryEncoding(builder: FlatBufferBuilder) = builder.startTable(4)
        fun addId(builder: FlatBufferBuilder, id: Long) = builder.addLong(0, id, 0L)
        fun addIndexType(builder: FlatBufferBuilder, indexType: Int) = builder.addOffset(1, indexType, 0)
        fun addIsOrdered(builder: FlatBufferBuilder, isOrdered: Boolean) = builder.addBoolean(2, isOrdered, false)
        fun addDictionaryKind(builder: FlatBufferBuilder, dictionaryKind: Short) = builder.addShort(3, dictionaryKind, 0)
        fun endDictionaryEncoding(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
    }
}
